#[macro_use]
extern crate glium;

use mc_render::assets::resource::{self, AssetsArchive ,TextureImageProvider}; 
use mc_render::glrender::texture::{CombinedTextureGen, CombinedTexture};
use mc_render::glrender::context;
use mc_render::glrender::mesh;
use mc_render::glrender;
use mc_render::model::model::TextureGen;
use std::io::{Read, Write, Seek};
use zip::ZipArchive;
use glium::glutin;
use glium::Surface;

#[test]
fn test_gltexture() {
    let s = std::env::var("ASSETS").expect("$env::ASSETS is not ref to a minecraft version.jar");
    let ifile = std::fs::File::open(s).unwrap();
    let zip = std::rc::Rc::new(std::cell::RefCell::new(AssetsArchive::new(ifile).unwrap()));

    let pvd = TextureImageProvider::from(zip.clone());

    let evloop = glutin::EventsLoop::new();

    let display = context::build_display((256, 256), &evloop, glutin::GlRequest::Specific(glutin::Api::OpenGl, (3, 3)));

    let mut gen = CombinedTextureGen::new( &display, pvd );

    for name in &["block/bricks", "block/oak_planks", "block/tripwire_hook"] {
        println!("{:?}", gen.get(name));
    }

    let tex = gen.build(32, 32, glium::texture::MipmapsOption::AutoGeneratedMipmaps).unwrap();

    println!("{:?}", tex);



    #[derive(Copy, Clone)]
    struct Vertex {
        position: [f32; 2],
        tex: [f32; 2],
        tex_id: i32,
    }

    glium::implement_vertex!(Vertex, position, tex, tex_id);

    
    

    // building the index buffer
    let index_buffer = glium::IndexBuffer::new(&display, glium::index::PrimitiveType::TrianglesList,
                                               &[0u16, 1, 2, 2, 1, 3]).unwrap();

    // compiling shaders and linking them together
    let program = glium::program!(&display,
        330 => {
            vertex: "
                #version 330

                uniform mat4 matrix;

                in vec2 position;
                in vec2 tex;
                in int tex_id;

                out vec3 v_tex;

                void main() {
                    v_tex = vec3(tex.x, tex.y, float(tex_id));
                    gl_Position =  matrix * vec4(position, 0.0, 1.0);
                }
            ",

            fragment: "
                #version 330

                uniform sampler2DArray tex;

                in vec3 v_tex;

                void main() {
                    gl_FragColor = texture(tex, v_tex);
                }
            "
        },
    ).unwrap();

    // drawing once

    // building the uniforms
    let uniforms = glium::uniform! {
        matrix: [
            [1.0, 0.0, 0.0, 0.0],
            [0.0, 1.0, 0.0, 0.0],
            [0.0, 0.0, 1.0, 0.0],
            [0.0, 0.0, 0.0, 1.0f32]
        ],
        tex: &tex
    };

    // drawing a frame
    let mut target = display.draw();
    target.clear_color(0.0, 0.0, 0.0, 0.0);

    // building the vertex buffer, which contains all the vertices that we will draw
    let dx = -0.4;
    let dy = -0.4;
    let tex_id = 0;
    let vertex_buffer = glium::VertexBuffer::new(&display,
        &[
            Vertex { position: [-0.5 + dx, -0.5 + dy], tex: [0.0, 0.0], tex_id },
            Vertex { position: [ 0.5 + dx, -0.5 + dy], tex: [0.0, 1.0], tex_id },
            Vertex { position: [-0.5 + dx,  0.5 + dy], tex: [1.0, 0.0], tex_id },
            Vertex { position: [ 0.5 + dx,  0.5 + dy], tex: [1.0, 1.0], tex_id },
        ]
    )
    .unwrap();

    target.draw(&vertex_buffer, &index_buffer, &program, &uniforms, &Default::default()).unwrap();
    
    let dx = 0.4;
    let dy = 0.4;
    let tex_id = 2;
    let vertex_buffer = glium::VertexBuffer::new(&display,
        &[
            Vertex { position: [-0.5 + dx, -0.5 + dy], tex: [0.0, 0.0], tex_id },
            Vertex { position: [ 0.5 + dx, -0.5 + dy], tex: [0.0, 1.0], tex_id },
            Vertex { position: [-0.5 + dx,  0.5 + dy], tex: [1.0, 0.0], tex_id },
            Vertex { position: [ 0.5 + dx,  0.5 + dy], tex: [1.0, 1.0], tex_id },
        ]
    )
    .unwrap();

    target.draw(&vertex_buffer, &index_buffer, &program, &uniforms, &Default::default()).unwrap();

    let dx = 0.4;
    let dy = -0.4;
    let tex_id = 1;
    let vertex_buffer = glium::VertexBuffer::new(&display,
        &[
            Vertex { position: [-0.5 + dx, -0.5 + dy], tex: [0.0, 0.0], tex_id },
            Vertex { position: [ 0.5 + dx, -0.5 + dy], tex: [0.0, 1.0], tex_id },
            Vertex { position: [-0.5 + dx,  0.5 + dy], tex: [1.0, 0.0], tex_id },
            Vertex { position: [ 0.5 + dx,  0.5 + dy], tex: [1.0, 1.0], tex_id },
        ]
    )
    .unwrap();

    target.draw(&vertex_buffer, &index_buffer, &program, &uniforms, &Default::default()).unwrap();

    let dx = -0.4;
    let dy = 0.4;
    let tex_id = 3;
    let vertex_buffer = glium::VertexBuffer::new(&display,
        &[
            Vertex { position: [-0.5 + dx, -0.5 + dy], tex: [0.0, 0.0], tex_id },
            Vertex { position: [ 0.5 + dx, -0.5 + dy], tex: [0.0, 1.0], tex_id },
            Vertex { position: [-0.5 + dx,  0.5 + dy], tex: [1.0, 0.0], tex_id },
            Vertex { position: [ 0.5 + dx,  0.5 + dy], tex: [1.0, 1.0], tex_id },
        ]
    )
    .unwrap();

    target.draw(&vertex_buffer, &index_buffer, &program, &uniforms, &Default::default()).unwrap();

    
    
    
    target.finish().unwrap();

    // reading the front buffer into an image
    let image: glium::texture::RawImage2d<u8> = display.read_front_buffer().unwrap();
    let image = image::ImageBuffer::from_raw(image.width, image.height, image.data.into_owned()).unwrap();
    let image = image::DynamicImage::ImageRgba8(image).flipv();
    image.save("../target/glium-test_texture.png").unwrap();

}


#[test]
fn test_glbaserender() {
    
    let s = std::env::var("ASSETS").expect("$env::ASSETS is not ref to a minecraft version.jar");
    let ifile = std::fs::File::open(s).unwrap();
    let zip = std::rc::Rc::new(std::cell::RefCell::new(AssetsArchive::new(ifile).unwrap()));
    let pvd = TextureImageProvider::from(zip.clone());

    use context::Context;
    let ctx = context::WindowHideContext::build(256, 256, glutin::GlRequest::Specific(glutin::Api::OpenGl, (3, 3)));

    let mut gen = CombinedTextureGen::new( ctx.facade(), pvd );

    for name in &["block/crafting_table_front", "block/diamond_block", "block/bricks", "block/water_still"] {
        println!("{:?}", gen.get(name));
    }

    let tex = gen.build(16, 16, glium::texture::MipmapsOption::AutoGeneratedMipmaps).unwrap();

    println!("{:?}", tex);

    use mesh::{MeshVertex, Mesh};
    use mc_render::model::model::Cubic;
    use mc_render::assets::data_type::Face;
    use mc_render::assets::data_type::Rotate90;
    use cgmath::{Matrix3, Vector3, Matrix4, Vector4, SquareMatrix, Deg};

    let c = Cubic {
        from: Vector3::new(0.0, 0.0, 0.0),
        to: Vector3::new(16.0, 16.0, 16.0),
    };

    let mut bl = Vector3::unit_x();
    let mut br = Vector3::unit_x();
    let mut tl = Vector3::unit_x();
    let mut tr = Vector3::unit_x();

    let mut m1 = Mesh::new();

    c.get_face_vert(Face::East, &mut bl, &mut br, &mut tl, &mut tr);
    println!("{:?} {:?} {:?} {:?}", bl, br, tl, tr);
    m1.append(&[
        MeshVertex { loc: [0, 0, 0], pos: bl.into(), tex: [0.0, 0.0], tex_id: 1, color: [255, 255, 255, 255], light: 0xFF },
        MeshVertex { loc: [0, 0, 0], pos: br.into(), tex: [16.0, 0.0], tex_id: 1, color: [255, 255, 255, 255], light: 0xFF },
        MeshVertex { loc: [0, 0, 0], pos: tl.into(), tex: [0.0, 16.0], tex_id: 1, color: [255, 255, 255, 255], light: 0xFF },
        MeshVertex { loc: [0, 0, 0], pos: tr.into(), tex: [16.0, 16.0], tex_id: 1, color: [255, 255, 255, 255], light: 0xFF },
    ]);

    c.get_face_vert(Face::Down, &mut bl, &mut br, &mut tl, &mut tr);
    println!("{:?} {:?} {:?} {:?}", bl, br, tl, tr);
    m1.append(&[
        MeshVertex { loc: [0, 0, 0], pos: bl.into(), tex: [0.0, 0.0], tex_id: 2, color: [255, 255, 255, 255], light: 0xFF },
        MeshVertex { loc: [0, 0, 0], pos: br.into(), tex: [16.0, 0.0], tex_id: 2, color: [255, 255, 255, 255], light: 0xFF },
        MeshVertex { loc: [0, 0, 0], pos: tl.into(), tex: [0.0, 16.0], tex_id: 2, color: [255, 255, 255, 255], light: 0xFF },
        MeshVertex { loc: [0, 0, 0], pos: tr.into(), tex: [16.0, 16.0], tex_id: 2, color: [255, 255, 255, 255], light: 0xFF },
    ]);

    c.get_face_vert(Face::North, &mut bl, &mut br, &mut tl, &mut tr);
    println!("{:?} {:?} {:?} {:?}", bl, br, tl, tr);
    m1.append(&[
        MeshVertex { loc: [0, 0, 0], pos: bl.into(), tex: [0.0, 0.0], tex_id: 3, color: [255, 255, 255, 255], light: 0xFF },
        MeshVertex { loc: [0, 0, 0], pos: br.into(), tex: [16.0, 0.0], tex_id: 3, color: [255, 255, 255, 255], light: 0xFF },
        MeshVertex { loc: [0, 0, 0], pos: tl.into(), tex: [0.0, 16.0], tex_id: 3, color: [255, 255, 255, 255], light: 0xFF },
        MeshVertex { loc: [0, 0, 0], pos: tr.into(), tex: [16.0, 16.0], tex_id: 3, color: [255, 255, 255, 255], light: 0xFF },
    ]);

    //let mut m2 = Mesh::new();
    c.get_face_vert(Face::North, &mut bl, &mut br, &mut tl, &mut tr);
    println!("{:?} {:?} {:?} {:?}", bl, br, tl, tr);
    m1.append(&[
        MeshVertex { loc: [0, 0, -1], pos: bl.into(), tex: [0.0, 0.0], tex_id: 4, color: [ 69, 173, 242, 255], light: 0xFF },
        MeshVertex { loc: [0, 0, -1], pos: br.into(), tex: [16.0, 0.0], tex_id: 4, color: [ 69, 173, 242, 255], light: 0xFF },
        MeshVertex { loc: [0, 0, -1], pos: tl.into(), tex: [0.0, 16.0], tex_id: 4, color: [ 69, 173, 242, 255], light: 0xFF },
        MeshVertex { loc: [0, 0, -1], pos: tr.into(), tex: [16.0, 16.0], tex_id: 4, color: [ 69, 173, 242, 255], light: 0xFF },
    ]);

    let lmmp = glium::texture::Texture2d::new(ctx.facade(), glrender::default_lmmp(false)).unwrap();
    let mut r = glrender::OffScreenRenderer::new(&ctx, &tex, &lmmp);


    let world = 
        Matrix4::from_diagonal(Vector4::new(0.5, 0.5, 0.5, 1.0)) *
        Matrix4::from_angle_x(Deg(30.0)) *
        Matrix4::from_angle_y(Deg(30.0));


    let center = Vector3::new(0, 0, 0);

    r.draw([m1].iter(), world, center).unwrap().save("../target/glium-test_texture_2.png").unwrap();

    
    
}